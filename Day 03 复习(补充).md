## Day 03 复习

### 一、Java SE 部分

1. public private protected default区别

   四种权限修饰符主要是作用域不同。从小到大是private default protected public. Java权限修饰符置于类的成员定义前，用来限定对象对该类成员的访问权限。

   - private  类内部
   - default(缺省) 类内部、同一个包中
   - protected 类内部、同一个包中、不同包的子类
   - public 类内部、同一个包中、不同包的子类、同一个工程中

   对于class的权限修饰只能用public 和 default

   - public类能在任何地方被访问
   - default类只能在同一个包内部的类访问

2. overload和overread区别

   overload重载，overread重写。

   - 重载严格按照定义去判断就行，两同一不同。相同的类，相同的方法名，不同的形参列表。至于形参列表不同，指的是参数个数或者类型不同，和返回值有无及类型，形参名称等无关。允许重载的存在是因为调用方法时先看方法名，再看形参列表。
   - 重写则表示子类中的方法可以和父类中某个方法**名称以及参数**都完成相同。那么通过子类创建的实例对象来调用这个方法时，会调用子类中定义的方法，相当于把父类中的那个完全相同的方法给覆盖了。这是面向对象的**多态性**的一种体现。子类覆盖父类方法时，只能比父类抛出更少的异常或者是抛出父类异常的子异常。因为子类可以解决父类的一些问题，不能比父类有更多的问题。而且子类的访问权限只能**比父类更大**，不能更小。如果父类的方法是private类型，那么子类就不存在覆盖的限制，相当于子类中增加了一个全新的方法。

   总结：

   - override是覆盖，覆盖一个方法并且对其重写，目的是达到不同的作用。最常见的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型用法之外，在继承中也存在着子类覆盖父类中的方法，覆盖需要注意：
     - 覆盖方法的标志和被覆盖方法的标志完全匹配，才能达到覆盖效果
     - 覆盖方法返回值和被覆盖方法返回值必须一致
     - 覆盖方法抛出的异常和被覆盖方法抛出的异常一致，或者是其子类
     - 被覆盖的方法不能是private,否则只是在子类中定义了一个新方法，没有对其进行覆盖
   - overload是重载，指我们能在同一个类中定义一些同名方法，通过不同的参数列表来区分它们。重载需要注意：
     - 不同参数列表包括：不同的参数类型、不同的参数个数、不同的参数顺序
     - 不能通过访问权限、返回值类型、抛出的异常、方法体等区分
     - 对于继承来说，如果某一个方法在父类中的权限是private,那么就不能在子类中对其进行重载，否则也只是定义了一个新方法。

3. 构造器Constructor是否可以被override

   构造器：构造方法、构造函数，是一种**特殊方法，用于初始化对象**

   构造器是生产对象的一种途径，如果可以被继承，那么对象就可以被复制了。子类可以通过继承构造器来生产父类对象，就会出现子类的引用指向父类对象的情况，这是不允许的。

   另一个角度。重写发生在子类父类之间，方法名，参数列表，返回值，修饰符，异常都相同。每个类名都不一样，而构造器名称和类名相同，这就不能算是继承了，因为没有继承关系，所以不能被重写。

   因为构造器不能被继承，所以不能重写override,但是可以被重载overload。所以在一个类中是可以有多个构造函数的。

4. 接口是否可以继承接口？抽象类是否可以实现接口(implements)?抽象类是否可以继承具体类（concrete class）?抽象类中是否可以有静态的main方法？

   - 接口可以继承接口

     可以想象成很多人USB接口不够用，就会有USB接口拓展。

   - 抽象类可以实现接口

     

   - 抽象类可以继承具体类

     Object就是个具体类，Java的API文档里，每个抽象类都写着直接或者间接继承自Object，前提是**实体类必须要有明确的构造函数**（这个其实和是否抽象没有关系，而是因为Java里子类继承父类所有但是不包括父类的构造，所以子类是只能调用父类构造。因为父类，在这个问题中是具体类，必须有供子类，这里是抽象类调用的构造）

   - 抽象类中可以有静态的main方法

   要明白接口和抽象类的本质和作用，想想为什么要提供这样的支持。记住抽象类和普通类的唯一区别就是**不能创建实例对象和允许有abstract方法**

   补充：

   - 接口

     接口只是一种约束形式，里面只包括一系列的方法声明，不包括方法实现的内容。所以这些方法可以在不同的地方被不同的类实现，而这些实现可以有不同的功能

     一个很好理解的栗子：

     > 我们身边最常见的接口就是电脑的usb接口了。我们可以想想，我们电脑的usb接口是不是就那么几个但是没有任何的具体的功能？但是当我们把u盘插到usb接口的时候，我们可以进行数据的传输；
     > 当我们把鼠标插入usb接口的时候，我们可以左键打开网页、文件夹等更多的功能；当我们把键盘插入到usb接口的时候我们可以打字，等等。虽然接入不同的设备可以进行不同的操作，但是上述的设备操作都是和电脑的数据交互。
     > 所以电脑在设置usb接口的时候，并没有实现具体的读写数据的功能，而是但不同的设备接入usb接口就可以实现不同的数据读写功能。这就是接口的好处，试想：如果每个接口都有特定的功能，鼠标要插这个接口，键盘插那个接口。那电脑就全是接口了，大大的浪费了资源，而且还不好看。

   - 抽象类

     对一系列看起来不同但本质上相同的具体概念的抽象，**不能实例化对象**，别的都一样。正是因为不能实例化，所以抽象类必须通过**继承才能被使用**。

     > 抽象类用来描述一种类型应该具备的基本特征与功能， 具体如何去完成这些行为由子类通过方法重写来完成，这点与接口很像.
     > 猫科均会吼叫，但属于猫科的猫与老虎、豹子等它们吼叫的声音确实不同。所以猫科这就是一个类，它只规定了猫科这类的动物有吼叫功能，但并不明确吼叫的细节，吼叫的细节的内容应该由猫与老虎这样的猫科子类重写吼叫的方法具体实现

     

     指一些*只有方法声明 没有具体的方法体* 的方法，一般都是存在于抽象类或者接口中

5. 写clone()方法时通常都有一行代码为什么

   clone有缺省行为，super.clone(); 因为首先要把父类中的成员复制到位，然后才是复制自己的成员
   
   补充：
   
   - 背景
   
     Java赋值是复制对象引用，如果希望得到一个对象副本，使用赋值操作是行不通的。要得到初始状态相同又各自独立的对象就要clone().Objecte对象有clone()方法，而且实现了对象中各属性的复制，但是**权限是protected**,所以自定义类要用有前提：
   
     - 实现Cloneable接口，这只是一个标记接口，自身是没有方法的
     - 覆盖也就是override clone()方法，权限提升为**public**
   
   - clone()干什么
   
     将现有的对象复制一份，产生和原来对象一样的对象，但是内存地址是不一样。背景是有时候对象A已经拥有了部分有效值，我们希望得到一个独立对象B但是对B的改动不影响A，而B的初始值由A来确定。这时候就用clone().
   
   - clone() 有缺省行为，super.clone()
   
     负责产生正确大小的空间，并且进行逐位复制
   
   - 使用clone()复制一个对象时，clone()会从Object类继承。所有具有clone功能的类都有一个特性，那就是直接或者间接地实现了Cloneable接口。
   
     ```Java
     protected Object clone() throws CloneNotSupportedException{
         if(!(this instanceof Cloneable)){
             throw new CloneNotSupportException("Class doesn't implement Cloneable");
             return internalClone((Cloneable) this);
         }
     }
     ```
   
    - 因此自定义类中要想对象可以被复制，就必须要重写Cloneable中的clone()方法。
   
      一个简单的栗子：
   
      ```Java
      @Data
      public class Person implements Cloneable {
          private String name;
          private Integer age;
          private Address address;
          @Override
          protected Object clone() throws CloneNotSupportedException {
              return super.clone();
          }
      }
       
      @Test
      public void testShallowCopy() throws Exception{
        Person p1=new Person();
        p1.setAge(31);
        p1.setName("Peter");
       
        Person p2=(Person) p1.clone();
        System.out.println(p1==p2);//false
        p2.setName("Jacky");
        System.out.println("p1="+p1);//p1=Person [name=Peter, age=31]
        System.out.println("p2="+p2);//p2=Person [name=Jacky, age=31]
      }
      ```
   
    - 另外，在使用clone的时候，还有深克隆和浅克隆之分。浅克隆仅仅复制所考虑的对象，不复制它所引用的对象，这样如果修改对象引用的对象可能还是原来的；深克隆要把复制对象所引用的对象也都复制一遍。
   
      比如这个栗子：
   
      ```Java
      @Data 
      //Person增加了Address类成员
      public class Address {
          private String type;
          private String value;
      }
      ```
   
      ```Java
      @Test
      public void testShallowCopy() throws Exception{
        Address address=new Address();
        address.setType("Home");
        address.setValue("北京");
       
        Person p1=new Person();
        p1.setAge(31);
        p1.setName("Peter");
        p1.setAddress(address);
       
        Person p2=(Person) p1.clone();
        System.out.println(p1==p2);//false
       
        p2.getAddress().setType("Office");
        System.out.println("p1="+p1);
        System.out.println("p2="+p2);
      }
      ```
   
      ```Java
      false
      p1=Person(name=Peter, age=31, address=Address(type=Office, value=北京))
      p2=Person(name=Peter, age=31, address=Address(type=Office, value=北京))
      ```
   
      会发现只修改了p2的地址，但是两个都改变了。这是因为**浅拷贝**
   
      > 浅拷贝：被复制对象的所有值属性都含有与原来对象的相同，而所有的对象引用属性仍然指向原来的对象。
      >
      > 深拷贝：在浅拷贝的基础上，所有引用其他对象的变量也进行了clone，并指向被复制过的新对象。
      >
      > 也就是说，一个默认的clone()方法实现机制，仍然是赋值。
      >
      > 如果一个被复制的属性都是基本类型，那么只需要实现当前类的cloneable机制就可以了，此为浅拷贝。
      >
      > 如果被复制对象的属性包含其他实体类对象引用，那么这些实体类对象都需要实现cloneable接口并覆盖clone()方法。
   
      所以这里的Adress类也要实现cloneable接口重写clone()方法
   
      ```Java
      @Data
      public class Address implements Cloneable {
          private String type;
          private String value;
       
          @Override
          protected Object clone() throws CloneNotSupportedException {
              return super.clone();
          }
      }
      ```
   
      而且，Person的clone()还需要显式地clone其引用成员
   
      ```Java
      @Data
      public class Person implements Cloneable {
          private String name;
          private Integer age;
          private Address address;
          @Override
          protected Object clone() throws CloneNotSupportedException {
              Object obj=super.clone();
              Address a=((Person)obj).getAddress();
              ((Person)obj).setAddress((Address) a.clone());
              return obj;
          }
      }
      ```
   
      ```Java
      false
      p1=Person(name=Peter, age=31, address=Address(type=Home, value=北京))
      p2=Person(name=Peter, age=31, address=Address(type=Office, value=北京))
      ```
   
      这样就可以了，但是两个就这么麻烦，m个可想而知，所以后面还有**序列化**操作，不深究了emmm.

### 二、计网部分

1. TCP为何可靠

   TCP有**三次握手建立连接，四次挥手关闭连接**的机制。除此之外，还有**滑动窗口和拥塞控制**算法，最关键的是还保留**超时重传**机制。对于每份报文也存在检验，保证可靠性

2. UDP为何不可靠

   UDP面向数据报**无连接**的。仅仅在IP数据报**头部加入校验和复用**，UDP**没有服务器和客户端**的概念，如果报文过长的话是交给IP切成小段，某一段废了报文就废了。

3. 简述TCP粘包现象

   - TCP粘包是指发送方发送的若干包数据到接收方时粘成一包。从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。

   - 为什么会出现粘包

     TCP是面向流协议，发送的单位是字节流。

     - 发送方原因

       TCP默认使用Nagle算法，这个算法主要做两件事。

       3.1.1 只有上一个分组得到了确认，才会发送下一个分组

       3.1.2 收集多个小分组，在一个确认到来时再一起发送

       所以Nagle算法可能造成发送方有粘包现象

     - 接收方原因

       TCP接到分组时，并不会立刻送到应用层去处理。或者说应用层处理不一定及时。实际上，TCP将收到的分组保存到接收缓存里，然后应用程序主动从缓存中读取收到的分组。

       这样一来，如果TCP分组接收分组的速度大于应用程序读分组的速度，多个包就被存到缓存了，应用程序读的时候，就会读到多个首尾相接粘到一起的包。

   - 什么时候需要处理

     - 如果多个分组本来就是同一数据的不同部分，比如一个大文件被分成多个分组发送，就不需要处理
     - 如果多个分组毫不相干，就需要处理

   - 如何处理

     - 发送方可以关闭Nagle算法
     - 接收方tcp没有处理机制，只能在应用层处理
     - 应用层处理是简单可行的，无论哪方造成都可以处理。方法就是循环处理，应用程序在处理从缓存读来的分组时，读完一条，就循环读下一条。对于判断每条数据的长度问题，可以通过格式化数据（固定信息长度或者加入分隔符等）或者把数据长度一并发送

4. 简述TCP协议的滑动窗口

   滑动窗口是传输层进行**流量控制**的一种措施，接收发通过告诉发送方自己的**窗口大小**，从而控制发送方的**发送速度**，防止发送方发送速度过快而导致自己被淹没。
   
   补充：
   
   - TCP每发送一次数据都需要一次应答然后继续发送，这样为每个数据包进行应答确认导致了数据往返时间长，网络吞吐量低。引入窗口之后即使往返时间较长也不会降低网络通信效率。可以指定窗口大小，就是**无需等待确认应答继续发送数据的最大值**
   
   - 窗口实现需要操作系统开辟一个缓存空间，发送方主机在等到确认应答之前发送缓冲区中保留的数据。如果按期收到了应答，就可以从缓存区清楚。
   
   - 如何控制窗口大小
   
     其实是在TCP头部设置一个字段window,接收端告诉发送端自己还有缓冲区可以收数据。那么发送端就可以根据这个接收端的处理能力来发送数据，而不是让它忙不过来。通常这个大小是由接收方窗口大小决定的。
   
     自行想象随着动态收发，这个窗口应该是滑动的，而且发送方窗口应该是包括发送窗口（已发未ACK）和可用窗口（未发但在接收方处理能力之内），接收方就只有接收窗口 了（没收到但可以收）
   
   
   
5. 简述TCP协议的拥塞控制
   
   拥塞是指在某段时间内，如果对网络中某一资源的**需求超过了该资源能提供的可用部分**，（资源需求总和大于可用资源）那么网络的性能就要变差，叫做拥塞。拥塞控制和流量控制是有区别的，拥塞控制往往是全局的。防止过多数据注入到网络中，只要TCP连接的端点不能收到对方的确认信息，就猜想发生了拥塞，但不知道发生在何处。而流量控制是对point to point通信的控制，是端到端的问题。拥塞控制是**降低整体网络中主机的发送速率**，而流量控制是**降低一台主机的发送速率**。
   
   拥塞控制的四种方法：
   
   - 慢开始
   - 拥塞避免
   - 快重传
   - 快恢复
   

​      5.1 慢开始和拥塞避免
​			发送方维持一个拥塞窗口cwnd,根据网络情况动态调整大小。网络拥塞时，路由器会丢弃报文。当发送方没有按时收到确认报文，就知道网络发生了拥塞。对于慢开始和拥塞避免需要结合cwnd来看。

- 慢开始的慢指的是，初始cwnd = 1（这时候指的是报文段个数，而不是真正传输时使用的字节流）

  5.1.1 开始发送方cwnd = 1,发送报文段M1，如果收到确认M1，cwnd = 2,并且发送M2,M3.

  5.1.2 发送方每收到一个确认报文段，cwnd+1(这里不包括丢失重传的确认)

  这样的话每隔一RRT，拥塞窗口就翻倍（随**传播轮次**指数增长）。说是慢开始，其实是指数级增长的，目的是为了试探网络情况，再逐渐增大cwnd.

  ![image-20220114142948875](https://img2020.cnblogs.com/blog/2537691/202201/2537691-20220114142953173-1397554494.png)
  5.1.3 但是这样指数增长下去，速率过大也会带来网络拥塞。所以还需要一个慢开始门限ssthresh.
  
  规则如下：
  
  - cwnd < ssthresh 使用慢开始算法
  - cwnd > ssthresh 停止慢开始，改用拥塞避免算法
  - cwnd == ssthresh 都可以
  
- 拥塞避免思路是让cwnd缓慢增大，不再加倍。每经过一个RRT就把发送方cwnd + 1，这样就从指数增长变成线性增长。

![image-20220114143446232](https://img2020.cnblogs.com/blog/2537691/202201/2537691-20220114143450234-1436522747.png)

 **无论是慢开始还是拥塞避免，只要发送方判断出现网络拥塞（依据是没有按时收到确认），那么就要把ssthresh设置为出现拥塞时的一半，但是不能小于2.然后cwnd重设为1，执行慢开始**

上述过程可以概括为**乘法减小**和**加法增大**。前者两个阶段只要ACK超时，cwnd就减半。后者指拥塞避免阶段，cwnd线性增长。两者合起来就是AIMD算法。

​    5.2  快重传和快恢复

​	5.2.1 快重传
​	在超时重传定时器溢出之前，**接收到连续三个重复冗余的ACK**，发送端就知道哪个报文段在传输过程中丢失了，于是会重发该报文段，不需要等待超时重传定时器溢出是再发送该报文。

​	5.2.2 快恢复
​	当发送方**连续收到三个重复确认**，执行乘法减小，ssthresh减半。由于发送发可能认为网络目前没有拥塞，所以和慢开始不同。区别在于不会将cwnd降到1，而是会降到**ssthresh的一半**，之后进行**拥塞避免来线性增加cwnd**而不是慢开始。


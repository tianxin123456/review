## Day 03 复习

### 一、Java SE 部分

1. public private protected default区别

   四种权限修饰符主要是作用域不同。从小到大是private default protected public. Java权限修饰符置于类的成员定义前，用来限定对象对该类成员的访问权限。

   - private  类内部
   - default(缺省) 类内部、同一个包中
   - protected 类内部、同一个包中、不同包的子类
   - public 类内部、同一个包中、不同包的子类、同一个工程中

   对于class的权限修饰只能用public 和 default

   - public类能在任何地方被访问
   - default类只能在同一个包内部的类访问

2. overload和overread区别

   overload重载，overread重写。

   - 重载严格按照定义去判断就行，两同一不同。相同的类，相同的方法名，不同的形参列表。至于形参列表不同，指的是参数个数或者类型不同，和返回值有无及类型，形参名称等无关。允许重载的存在是因为调用方法时先看方法名，再看形参列表。
   - 重写则表示子类中的方法可以和父类中某个方法**名称以及参数**都完成相同。那么通过子类创建的实例对象来调用这个方法时，会调用子类中定义的方法，相当于把父类中的那个完全相同的方法给覆盖了。这是面向对象的**多态性**的一种体现。子类覆盖父类方法时，只能比父类抛出更少的异常或者是抛出父类异常的子异常。因为子类可以解决父类的一些问题，不能比父类有更多的问题。而且子类的访问权限只能**比父类更大**，不能更小。如果父类的方法是private类型，那么子类就不存在覆盖的限制，相当于子类中增加了一个全新的方法。

   总结：

   - override是覆盖，覆盖一个方法并且对其重写，目的是达到不同的作用。最常见的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型用法之外，在继承中也存在着子类覆盖父类中的方法，覆盖需要注意：
     - 覆盖方法的标志和被覆盖方法的标志完全匹配，才能达到覆盖效果
     - 覆盖方法返回值和被覆盖方法返回值必须一致
     - 覆盖方法抛出的异常和被覆盖方法抛出的异常一致，或者是其子类
     - 被覆盖的方法不能是private,否则只是在子类中定义了一个新方法，没有对其进行覆盖
   - overload是重载，指我们能在同一个类中定义一些同名方法，通过不同的参数列表来区分它们。重载需要注意：
     - 不同参数列表包括：不同的参数类型、不同的参数个数、不同的参数顺序
     - 不能通过访问权限、返回值类型、抛出的异常、方法体等区分
     - 对于继承来说，如果某一个方法在父类中的权限是private,那么就不能在子类中对其进行重载，否则也只是定义了一个新方法。

3. 构造器Constructor是否可以被override

   因为构造器不能被继承，所以不能重写override,但是可以被重载overload

4. 接口是否可以继承接口？抽象类是否可以实现接口(implements)?抽象类是否可以集成具体类（concrete class）?抽象类中是否可以有静态的main方法？

   - 接口可以继承接口
   - 抽象类可以实现接口
   - 接口可以继承具体类
   - 抽象类中可以有静态的main方法

   要明白接口和抽象类的本质和作用，想想为什么要提供这样的支持。记住抽象类和普通类的唯一区别就是**不能创建实例对象和允许有abstract方法**

5. 写clone()方法时通常都有一行代码为什么

   clone有缺省行为，super.clone(); 因为首先要把父类中的成员复制到位，然后才是复制自己的成员

### 二、计网部分

1. TCP为何可靠

   TCP有**三次握手建立连接，四次挥手关闭连接**的机制。除此之外，还有**滑动窗口和拥塞控制**算法，最关键的是还保留**超时重传**机制。对于每份报文也存在检验，保证可靠性

2. UDP为何不可靠

   UDP面向数据报**无连接**的。仅仅在IP数据报**头部加入校验和复用**，UDP**没有服务器和客户端**的概念，如果报文过长的话是交给IP切成小段，某一段废了报文就废了。

3. 简述TCP粘包现象

   - TCP粘包是指发送方发送的若干包数据到接收方时粘成一包。从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。

   - 为什么会出现粘包

     TCP是面向流协议，发送的单位是字节流。

     - 发送发原因

       TCP默认使用Nagle算法，这个算法主要做两件事。

       3.1.1 只有上一个分组得到了确认，才会发送下一个分组

       3.1.2 收集多个小分组，在一个确认到来时再一起发送

       所以Nagle算法可能造成发送方有粘包现象

     - 接收方原因

       TCP接到分组时，并不会立刻送到应用层去处理。或者说应用层处理不一定及时。实际上，TCP将收到的分组保存到接收缓存里，然后应用程序主动从缓存中读取收到的分组。

       这样一来，如果TCP分组接收分组的速度大于应用程序读分组的速度，多个包就被存到缓存了，应用程序读的时候，就会读到多个首尾相接粘到一起的包。

   - 什么时候需要处理

     - 如果多个分组本来就是同一数据的不同部分，比如一个大文件被分成多个分组发送，就不需要处理
     - 如果多个分组毫不相干，就需要处理

   - 如何处理

     - 发送方可以关闭Nagle算法
     - 接收发tcp没有处理机制，只能在应用层处理
     - 应用层处理是简单可行的，无论哪方造成都可以处理。方法就是循环处理，应用程序在处理从缓存读来的分组时，读完一条，就循环读下一条。对于判断每条数据的长度问题，可以通过格式化数据或者把数据长度一并发送

4. 简述TCP协议的滑动窗口

   滑动窗口是传输层进行**流量控制**的一种措施，接收发通过告诉发送方自己的**窗口大小**，从而控制发送方的**发送速度**，防止发送方发送速度过快而导致自己被淹没。
   
   
   
5. 简述TCP协议的拥塞控制
   
   